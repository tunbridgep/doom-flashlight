class StealthSpawner : EventHandler
{
    const max_health_small = 100;

    void StealthMonsters(Actor monster)
    {
        let dice = StealthMonsterConfig.GetChance();
            
        if (dice.Roll() || monster.bSTEALTH)
        {
            monster.GiveInventory("StealthManager",1);
            Debug.LogVerbose("Monster "..monster.GetTag().." was replaced with a Stealth variant based on a roll of "..dice.GetLastRoll().." ("..dice.GetChance().." percent chance)");
        }
    }
    
    override void WorldThingSpawned(WorldEvent e)
    {
        Actor a = e.Thing;
        if (!a)
            return;
            
        if (a.bISMONSTER && !a.bCORPSE && a.bCOUNTKILL && a.GetLevelSpawnTime() <= 5)// && StealthMonsterConfig.IsEnabled())
            StealthMonsters(a);
    }
}

//enables/disables Stealth based on surrounding illumination
class StealthManager : PermanentItem
{
    bool smallHealth;
    bool defaultStealth;
    
    override void AttachToOwner(Actor other)
    {
        smallHealth = other.health <= 100; //This has to be done here so we get it's max HP, not it's current HP;
        defaultStealth = other.bSTEALTH; //Store if we were initially a stealth monster.
        super.AttachToOwner(other);
    }
    
    override void DoEffect()
    {
        int light_level = owner.cursector.lightlevel;
        bool in_threshold = defaultStealth || !StealthMonsterConfig.UsesThreshold() || light_level <= StealthMonsterConfig.GetThreshold(); //keep stealth even in bright areas, if it was initially a stealth monster
        bool revealed = owner.CountInv("StealthRemover") > 0; //we CAN reveal monsters that were initially stealth monsters;
        bool stealth_enabled = defaultStealth || StealthMonsterConfig.IsEnabled(); //keep stealth even if we don't have stealth monsters enabled, if it was initially a stealth monster
        bool small = defaultStealth || !StealthMonsterConfig.IsSmallOnly() || smallHealth; //keep stealth even if it isn't a small monster, if it was initially a stealth monster
        
        owner.bSTEALTH = stealth_enabled && in_threshold && !revealed && small;
        
        float newalpha = !(owner.bSTEALTH) * 1.0;
        owner.alpha = Mathf.Lerp(owner.alpha,newalpha,0.035);
    }
    
    override void OwnerDied()
    {
        owner.bSTEALTH = false;
        Destroy();
        super.OwnerDied();
    }
}

class StealthRemover : PermanentItem
{
    override void AttachToOwner(Actor other)
    {
        Debug.LogVerbose("Stealth Remover added to "..other.GetTag());
        super.AttachToOwner(other);
    }
    
    int ticks;
    override void DoEffect()
    {
        ticks++;
        if (ticks >= 35)
            Destroy();
    }
}
